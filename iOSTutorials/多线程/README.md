
# 多线程


### 一、简介

#### 线程和进程、任务（Thread, Process and Task）

- 进程（process）：指的是一个正在运行中的可执行文件。每一个进程都拥有独立的虚拟内存空间和系统资源，包括端口权限等，且至少包含一个主线程和任意数量的辅助线程。另外，当一个进程的主线程退出时，这个进程就结束了；
- 线程（thread）：指的是一个独立的代码执行路径，也就是说线程是代码执行路径的最小分支。在 iOS 中，线程的底层实现是基于 POSIX threads API 的，也就是我们常说的 pthreads ；
- 任务（task）：指的是我们需要执行的工作，是一个抽象的概念，用通俗的话说，就是一段代码。

#### 串行和并行（Serial VS. Concurrent）

从本质上来说，串行和并发的主要区别在于允许同时执行的任务数量。
- 串行：指的是一次只能执行一个任务，必须等一个任务执行完成后才能执行下一个任务。GCD 中把这种队列成为 Serial Dispatch Queue
- 并行：则指的是允许多个任务同时执行，不需要上一个执行完，就能执行下一个。在 GCD 中，这种队列被称为 Concurrent Dispatch Queue。

这两种，均遵循 FIFO 的入队顺序原则。

> 举一个简单的例子，在三个任务中输出1、2、3，串行队列输出是有序的1、2、3，但是并行队列的先后顺序就不一定了。
>
> 那么，并行队列又是怎么在执行呢？
>
> 虽然可以同时多个任务的处理，但是并行队列的处理量，还是要根据当前系统状态来。如果当前系统状态最多处理2个任务，那么1、2会排在前面，3什么时候操作，就看1或者2谁先完成，然后3接在后面。


#### 同步和异步(Sync VS. Async)

串行与并行针对的是队列，而同步与异步，针对的则是线程。
同步和异步操作的主要区别在于是否等待任务执行完成，亦即是否阻塞当前线程。
同步操作会阻塞当前线程，必须要等同步线程中的任务执行完成后，返回之后，再继续执行接下来的代码。
而异步操作则恰好相反，它会在调用后立即返回，不会等待。

#### 队列和线程（Queue VS. Thread）

**一个队列由一个或多个任务组成，当这些任务要开始执行时，系统会分别把他们分配到某个线程上去执行**。当有多个系统核心时，为了高效运行，这些核心会将多个线程分配到各核心上去执行任务，对于系统核心来说并没有任务的概念。

**对于一个并行队列来说，其中的任务可能被分配到多个线程中去执行，即这个并行队列可能对应多个线程。对于串行队列，它每次对应一个线程，这个线程可能不变，可能会被更换。**

每一时刻，一个线程都只能执行一个任务。一个线程也可能是闲置或者挂起的，因此线程存在时不一定就在执行任务。

队列和线程可以说是两个层级的概念。队列是为了方便使用和理解的抽象结构，而线程是系统级的进行运算调度的单位，他们是上下层级之间的关系。

在 iOS 中，有两种不同类型的队列，分别是串行队列和并发队列。

正如我们上面所说的，串行队列一次只能执行一个任务，而并发队列则可以允许多个任务同时执行。iOS 系统就是使用这些队列来进行任务调度的，它会根据调度任务的需要和系统当前的负载情况动态地创建和销毁线程，而不需要我们手动地管理。


### 二、iOS 中的并发编程模型

在其他许多语言中，为了提高应用的并发性，我们往往需要自行创建一个或多个额外的线程，并且手动地管理这些线程的生命周期，这本身就已经是一项非常具有挑战性的任务了。此外，对于一个应用来说，最优的线程个数会随着系统当前的负载和低层硬件的情况发生动态变化。因此，一个单独的应用想要实现一套正确的多线程解决方案就变成了一件几乎不可能完成的事情。而更糟糕的是，线程的同步机制大幅度地增加了应用的复杂性，并且还存在着不一定能够提高应用性能的风险。

然而，值得庆幸的是，**在 iOS 中，苹果采用了一种比传统的基于线程的系统更加异步的方式来执行并发任务。与直接创建线程的方式不同，我们只需定义好要调度的任务，然后让系统帮我们去执行这些任务就可以了。我们可以完全不需要关心线程的创建与销毁、以及多线程之间的同步等问题，苹果已经在系统层面帮我们处理好了，并且比我们手动地管理这些线程要高效得多**。

因此，我们应该要听从苹果的劝告，珍爱生命，远离线程。不过话又说回来，尽管队列是执行并发任务的首先方式，但是毕竟它们也不是什么万能的灵丹妙药。所以，在以下三种场景下，我们还是应该直接使用线程的：
- 用线程以外的其他任何方式都不能实现我们的特定任务；
- 必须实时执行一个任务。因为虽然队列会尽可能快地执行我们提交的任务，但是并不能保证实时性；
- 你需要对在后台执行的任务有更多的可预测行为。

### 三、iOS 中的几种多线程方案
- pthreads
- NSThread
- NSOperation
- GCD


### 四、NSRunloop

### 五、多线程下的线程安全问题
- 资源竞争
- 死锁
- 互斥锁
- 资源饥饿（Starvation）
- 优先级反转

### 参考

- [五个案例让你明白GCD死锁](http://www.superqq.com/blog/2015/10/16/five-case-know-gcd/)
- [iOS 并发编程之 Operation Queues](http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/)
- [队列（Queue）与线程（Thread）的关系](https://starrrry.github.io/14731507957502.html)
- [iOS多线程中，队列和执行的排列组合结果分析](http://www.cnblogs.com/dsxniubility/p/4296937.html)
- [并发编程 - objc.io](https://www.objc.io/issues/2-concurrency/)
- [Concurrency Programming Guide](https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html)
- https://www.appcoda.com/ios-concurrency/
- https://bestswifter.com/multithreadconclusion/
- http://www.jianshu.com/p/0b0d9b1f1f19
- [关于 iOS 多线程，都在这里了](http://www.jianshu.com/p/6a6722f12fe3)
